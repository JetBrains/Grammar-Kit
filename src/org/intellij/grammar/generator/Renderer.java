/*
 * Copyright 2011-2025 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 */

package org.intellij.grammar.generator;

import com.intellij.openapi.util.Couple;
import org.intellij.grammar.KnownAttribute;
import org.intellij.grammar.psi.BnfFile;
import org.intellij.grammar.psi.BnfRule;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import static org.intellij.grammar.generator.ParserGeneratorUtil.*;

/**
 * This interface provides methods for generating identifiers for
 * various components in the parsers generated by the plugin.
 * It was created as a means of specifying the format of identifiers
 * for different programming languages (in our case, Java and Kotlin).
 */
public interface Renderer {
  @NotNull String RESERVED_SUFFIX = "_$";

  @NotNull String toIdentifier(@NotNull String text, @Nullable NameFormat format, @NotNull Case textCase);

  default @NotNull String getBaseName(@NotNull String name) {
    return toIdentifier(name, null, Case.AS_IS);
  }

  /**
   * Given the function name returned previously from the {@link Renderer#getFuncName}
   * method and the index number, returns a new name constructed from the two values.
   */
  @NotNull String getNextName(@NotNull String funcName, int i);

  /**
   * Given a bnf rule, returns the name of the method used in the generated
   * parser to implement handling this rule. This method takes into account
   * the rules regarding identifier tokens in the target language.
   */
  @NotNull String getFuncName(@NotNull BnfRule rule);

  /**
   * Undoes the effect of the {@link Renderer#getFuncName} method.
   */
  @NotNull String unwrapFuncName(@NotNull String funcName);

  @NotNull String getWrapperParserMetaMethodName(@NotNull String nextName);

  default @NotNull String getGetterName(@NotNull String text) {
    return toIdentifier(text, NameFormat.from("get"), Case.CAMEL);
  }

  default @NotNull String getTokenSetConstantName(@NotNull String nextName) {
    return toIdentifier(nextName, null, Case.UPPER) + "_TOKENS";
  }

  default @NotNull String getWrapperParserConstantName(@NotNull String nextName) {
    return getBaseName(nextName) + "_parser_";
  }

  default @NotNull String getRulePsiClassName(@NotNull BnfRule rule, @Nullable NameFormat format) {
    return toIdentifier(rule.getName(), format, Case.CAMEL);
  }

  default @NotNull Couple<@NotNull String> getQualifiedRuleClassName(@NotNull BnfRule rule) {
    BnfFile file = (BnfFile)rule.getContainingFile();
    String psiPackage = getAttribute(rule, KnownAttribute.PSI_PACKAGE);
    String psiImplPackage = getAttribute(rule, KnownAttribute.PSI_IMPL_PACKAGE);
    NameFormat psiFormat = getPsiClassFormat(file);
    NameFormat psiImplFormat = getPsiImplClassFormat(file);
    return Couple.of(psiPackage + "." + getRulePsiClassName(rule, psiFormat),
                     psiImplPackage + "." + getRulePsiClassName(rule, psiImplFormat));
  }

  default @NotNull String getElementType(@NotNull BnfRule rule, @NotNull Case cas) {
    String elementType = getAttribute(rule, KnownAttribute.ELEMENT_TYPE);
    if ("".equals(elementType)) return "";
    NameFormat prefix = NameFormat.from(getAttribute(rule, KnownAttribute.ELEMENT_TYPE_PREFIX));
    return toIdentifier(elementType != null ? elementType : rule.getName(), prefix, cas);
  }

  @Nullable String getRuleDisplayName(@NotNull BnfRule rule, boolean force);
}
