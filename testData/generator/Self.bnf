{
  parserClass="Self"
  extendedPin=false
  name(".*")=""
  stubParserClass="org.intellij.grammar.parser.GeneratedParserUtilBase"
  formattingBuilderClass="org.intellij.grammar.BnfFormattingModelBuilder"

  implements="org.intellij.grammar.psi.BnfCompositeElement"
  extends="org.intellij.grammar.psi.impl.BnfCompositeElementImpl"

  psiClassPrefix="Bnf"
  psiImplClassSuffix="Impl"
  psiPackage="org.intellij.grammar.psi"
  psiImplPackage="org.intellij.grammar.psi.impl"
  psiVisitorName=""

  elementTypeHolderClass="org.intellij.grammar.psi.BnfTypes"
  elementTypePrefix="BNF_"
  elementTypeClass="org.intellij.grammar.psi.BnfCompositeElementType"
  tokenTypeClass="org.intellij.grammar.psi.BnfTokenType"
  
  // tokens
  OP_EQ="="
  OP_IS="::="
  OP_OR="|"
  OP_OPT="?"
  OP_ONEMORE="+"
  OP_ZEROMORE="*"
  OP_AND="&"
  OP_NOT="!"
  SEMICOLON=";"
  LEFT_BRACE="{"
  RIGHT_BRACE="}"
  LEFT_BRACKET="["
  RIGHT_BRACKET="]"
  LEFT_PAREN="("
  RIGHT_PAREN=")"

  tokens=[id string number]

  implements("rule|attr")="org.intellij.grammar.psi.BnfNamedElement"
  extends("rule|attr")="org.intellij.grammar.psi.impl.BnfNamedElementImpl"

  around("::=|\|")="spaces(1)"
  around("=|rule")="none()"
  before("\*|\+|\)|\;|\}")="none()"
  after("\(|\[|\{|predicate_sign")="none()"
  after("quantified|attr|modifier")="spaces(1)"
  before("quantifier")="none()"
  before("attrs")="spaces(1)"
  around(".*expression|reference_or_token")="spaces(1)"

  normalIndent("attrs")="attr"
  continuationIndent("paren_expression")=".*"
  continuationIndent("choice")=".*"

  alignment("choice")=".*"
  alignment("attrs|paren_expression")="except:\{|\}"
}

grammar ::= (attrs | rule) *

rule ::= modifier* id '::=' expression attrs? ';'? {pin=3 recoverUntil="rule_recover_until"}
private rule_recover_until::=!'{'

expression ::= choice?

modifier ::= 'private' | 'external' | 'wrapped';

attrs ::= '{' attr* '}' {pin=1}

attr ::= id attr_pattern? '=' attr_value ';'? {pin=1 recoverUntil="attr_recover_until"}
private attr_recover_until::=!'}'
attr_value ::= (reference_or_token | literal_expression) !'=';
attr_pattern ::= '(' string ')'

choice ::= '{' sequence ('|' sequence)* '}' | sequence choice_tail* { extends="expression" }
private choice_tail ::= '|' sequence {pin=1}

sequence ::= option + { extends="expression" }

private option ::= quantified | predicate;
predicate ::=  predicate_sign  simple { extends="expression" }
predicate_sign ::= ('&' | '!')
quantified ::= '[' expression ']' | simple quantifier? { extends="expression" }
quantifier ::= '?' | '+' | '*'

private simple ::= !(modifier* id '::=' ) reference_or_token | literal_expression | paren_expression;
reference_or_token ::= id  { extends="expression" mixin="org.intellij.grammar.psi.impl.BnfRefOrTokenImpl"}
literal_expression ::= string_literal_expression | number { extends="expression" }
string_literal_expression ::= string { extends="literal_expression" mixin="org.intellij.grammar.psi.impl.BnfStringImpl"}
paren_expression ::= '(' expression ')' { pin=1 extends="expression" }



